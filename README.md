# DAILY-BYTE

Code snippets from the daily byte- subscribe: <https://thedailybyte.dev/>

## Reverse a string

Given a string, reverse all of its characters and return the resulting string

## Valid Palindrome

Given a string, return whether or not it forms a palindrome ignoring case and non-alphabetical characters.

### leetcode: <https://leetcode.com/problems/valid-palindrome/description/>

## Vacuum-robot

Given a string representing the sequence of moves a robot vacuum makes, return whether or not it will return to its original position. The string will only contain L, R, U, and D characters, representing left, right, up, and down respectively.

### leetcode: <https://leetcode.com/problems/robot-return-to-origin/description/>

## Correct Capitalization

Given a string, return whether or not it uses capitalization correctly. A string correctly uses capitalization if all letters are capitalized, no letters are capitalized, or only the first letter is capitalized.

### leetcode: <https://leetcode.com/problems/detect-capital/description/>

## Add Binary

Given two binary strings (strings containing only 1s and 0s) return their sum (also as a binary string).
Note: neither binary string will contain leading 0s unless the string itself is 0

### leetcode: <https://leetcode.com/problems/add-binary/>

## Longest Common Prefix

Given an array of strings, return the longest common prefix that is shared amongst all strings.
Note: you may assume all strings only contain lowercase alphabetical characters.

### leetcode: <https://leetcode.com/problems/longest-common-prefix/description/>

## Valid Palindrome with removal

Given a string and the ability to delete at most one character, return whether or not it can form a palindrome.

### leetcode: <https://leetcode.com/problems/valid-palindrome-ii/>

## Valid Palindrome number

Given an integer x, return true if x is a palindrome, and false otherwise.

### leetcode: <https://leetcode.com/problems/palindrome-number/>

## Fibonacci Number

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

### leetcode: <https://leetcode.com/problems/fibonacci-number/>

## Unique paths(grid traveller in a 2D array)

There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.

### leetcode: <https://leetcode.com/problems/unique-paths/>

## Binary Search

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

### leetcode: <https://leetcode.com/problems/binary-search/description/>

## Pow(x,n)

Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

### leetcode: <https://leetcode.com/problems/powx-n/>

## Reverse String

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

### leetcode: <https://leetcode.com/problems/reverse-string/>

## Reverse Integer

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

### leetcode: <https://leetcode.com/problems/reverse-integer/description/>

## Regular Expression matching

Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

'.' Matches any single character.​​​​
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

<https://redquark.org/leetcode/0010-regular-expression-matching/>

### leetcode

## Missing number

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

### leetcode: <https://leetcode.com/problems/missing-number/description/>

## Sqrt(x)

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

### leetcode: <https://leetcode.com/problems/sqrtx/description/>

## First unique character in a string

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

### leetcode: <https://leetcode.com/problems/first-unique-character-in-a-string/description/>

## Single Number I

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

### leetcode: <https://leetcode.com/problems/single-number/description/>

